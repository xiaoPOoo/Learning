
1.双冒号 ::的作用域运算符，当前边没有写的时候，是全局的作用域
	<< 运算符可以拼接输出的字符
	c++中输出的时候不需要标记%d %s %c %f 等格式化的输出
	换行\n \r\n  但是在c++中，只需要endl就可以了
	标准输入输出流 i--input输入，o--output输出 类似于stdio
int main()
{
	//cout是输出流对象
	std::cout << "hello world" << endl;//当引入命名空间的时候，这一行相当于是下边的一行的全称
	//  << 运算符可以拼接输出的字符
	// c++中输出的时候不需要标记%d %s %c %f 等格式化的输出
	// 换行\n \r\n  但是在c++中，只需要endl就可以了
	cout << "hello world" << 12345  <<endl;//endl是结束输出并换行

	system("pause");//阻塞
	return EXIT_SUCCESS;
}
============================================================================================
1.命名空间的嵌套
eg：
	namespace BB{
		int a=333;
		namespace CC{
			int cc=666;
		}		
	}
	void testbb(){
		cout<<BB::a<<BB::CC::cc<<endl;
	}
2.命名空间下可以存放变量。函数。结构体。类。
3.命名空间必须申明在全局作用域下。即不允许在函数等中声明命名空间。
4.命名空间是开放的，可以随时向命名空间下添加新的成员。即有同样的命名空间存在的时候是做一个合并的操作
eg:
	namespace B{
		int a=10;		
	}
	namespace B{
		int b=100;
	}
	void test(){
		cout<<B::a<<endl;
		cout<<B::b<<endl;
	}
result:10
       100
5.命名空间是可以匿名的（静态变量在编译前就已经存在，只能在本文件中使用）
namespace{
	int c=0;
	int d=30;//此时的c和d相当于前边加了static关键字
	//static int c=0
	//static int d=30;
}
void test1(){
	cout<<c<<endl;
}
6.命名空间是可以起别名的

namespace longnamespace{
	int i=100;
}
void test2(){
	namespace shortnamespace=longnamespace;
	cout<<shortnamespace::i<<endl;
}

总结：
	1.命名空间解决命名冲突的问题
	2.可以存放结构体、类、函数、、、、
	3.命名空间可以嵌套
	4.命名空间是开放的
	5.命名空间是可以匿名的
	6.命名空间可以起别名
============================================================================================
#include "stdafx.h"
#include "iostream"
using namespace std;

namespace wangzhe {
	int id = 1;
}
namespace LOL {
	int id = 2222;
}
void test() {
	//using声明
	//当就近原则和using声明同时出现时候，要避免二义性
	//int id = 4;//此行编译不通过
	using wangzhe::id;
	cout << id << endl;
}
void test1() {
	//2,using 编译指令
	int id = 20;//当using编译指令和就近原则同时存在的时候，使用就近原则，如果没有这一行，输出的是wnagzhe中的id
	using namespace wangzhe;
	cout << id << endl;
}
void test2() {
	int id = 40;
	using namespace wangzhe;
	using namespace LOL;
	//如果出现就近原则，则使用就近原则，如果没有指定就近原则的时候，必须指定是哪一个命名空间下的变量
	cout << LOL::id << endl;
	cout << id << endl;

}
int main()
{
	test();
	cout << "==============" << endl;
	test1();
	cout << "==============" << endl;
	test2();

	system("pause");
    return 0;
}
============================================================================================
c++对于c语言的增强
1.函数的返回值必须要有
c++中除了void返回值外，别的返回值都要写return，不然是编译通不过的
2.函数的参数的个数必须一致
3.类型的转换的增强
eg:
c语言：
void test() {
	char *p = malloc(64);
}
c++语言：
void test04() {
	char *p =(char *) malloc(64);
}
4.struct的增强
c语言：
	struct Person {
		int age;
		//c语言结构体下不可以放函数
	};
	void test2() {
		struct Person P;//c语言下声明一个结构体变量的时候，必须要加struct
	}
c++语言：
	struct Person {
		int age;
		void fun() { age++; }//c语言结构体下可以放函数
	};
	void test2() {
		Person P;//c语言下声明一个结构体变量的时候，可以不加struct
	}
5.布尔类型的增强
	c语言下没有布尔类型 bool (true false)
	bool flag=true;//true的本质为1，即使修改了还是1
	bool flag=false;//false的本质为0
	sizeof(bool)=1;布尔类型的大小为一个字节
6.三目运算增强
c语言：
	void test(){
		int a=10;
		int b=20;
		printf("res=%d\n",a>b?a:b);
		//printf("res=%d\n",a>b?a:b=100);//c语言下边是不可以这么写的
		//因为c语言下的三目运算符返回的是值，即a>b?a:b返回的是20，再将20=100,肯定是错的
		//可以改成如下的：
		printf("res=%d\n",*(a>b?&a:&b)=100);//这样是可以的
	}
c++语言：	
	void test(){
		int a=10;
		int b=20;
		printf("res=%d\n",a>b?a:b);
		printf("res=%d\n",a>b?a:b=100);//c++语言下边是可以这么写的，而且执行后b=100;
		//c++语言下三目返回的是变量，即a>b?a:b返回的是b,再将b=100是对的
	}
7.const增强
c语言：
	const int a = 100;//全局cons修饰的变量收到常亮区保护，是不允许改变的
	test1() {
		int *p = &a;
		//*p = 200;//虽然编译通过，但是运行报错
	}
	test2() {
	const int c = 100;//局部const修饰的变量可以间接的修改
	//c = 20;//直接修改是不行的
	int *q = &c;
	*q = 10;
	printf("*q=%d\n", *q);
	}
c++语言：	
	const int a = 100;//全局cons修饰的变量收到常亮区保护，是不允许改变的
	void test1() {
		int *p =(int *) &a;
		//*p = 200;//虽然编译通过，但是运行报错
	}
	void test2() {
		const int c = 100;
		//c = 20;//直接修改是不行的
		int *q = (int *)&c;//间接修改是修改不成功的
		*q = 10;
		printf("*q=%d\n", *q);
		int arr[c];//可以用来初始化数组，c是真正的常量
	}
========================================================================================
c语言下边的const默认在前边加了extern,而c++只有 extern const a=100;这样声明的变量才可以在别的文件中使用
即：const在c语言中默认是外部链接属性，而在c++中默认是内部链接属性
========================================================================================
对于const分配内存的情况：
	////1.对const修饰的变量取地址的时候，会分配临时内存
	void test() {
		const int m_A = 10;
		int *P = (int *)&m_A;//这个时候会分配内存
	}
	//2.加了extern关键字后会分配内存
	//3.使用变量初始化const修饰的变量
	void test1() {
		int a = 10;
		const int b = a;//用变量初始化const修饰的变量时候，会分配内存
		const int bb = 99;//用常量初始化const修饰的变量时候，不会分配内存

		int *p = (int *)&b;
		int *q = (int *)&bb;
		*p = 20;//只要分配内存了，都可以修改值
		*q = 100;//没有分配内存的时候，是不会修改值的
		cout << "b=" << b<<"   bb=  " <<bb<< endl;
	}
	//4,对于自定义的数据类型，是分配内存的
	struct Person {
		string name;
		int age;
	};
	void test3() {
		const Person p;
		/*p.age = 10;
		p.name = "wbs";*///这样是不允许直接修改的
		Person *pp = (Person *)&p;
		pp->age = 10;
		pp->name = "wbs";
		cout << pp->age << pp->name << endl;
	}
============================================================================================
不建议使用宏定义 #define
因为#define是没有类型的；宏定义是不区分作用域的；卸载宏定义用#undefine;尽量用const代替#define
============================================================================================
引用：（必须初始化，一旦初始化，就不可以修改它的指向）
	int a=10;
	int &b=a;//类型 & 别名=原名;引用就是起别名；类型要一致
	b=20;//a同样是被修改了的，因为他们用的是同一块儿内存
	void test1() {
		int a = 10;
		int &b = a;//类型 & 别名=原名;引用就是起别名；类型要一致
		b = 20;//a同样是被修改了的，因为他们用的是同一块儿内存
		cout << a << b<<endl;
	}
	void test2() {
		int a = 10;
		int &b = a;//类型 & 别名=原名;引用就是起别名；类型要一致
		//引用必须要初始化，初始化后就不可以修改指向了，即内存是不变的 
		int c = 20;
		b = c;//赋值
		cout << a << endl;
		cout << b << endl;
		cout << c << endl;
	}
	void test3() {
		//如何建立数组的引用
		int arr[10];
		int(&Arr)[10] = arr;
		for (int i = 0; i < 10; i++) {
			arr[i] = i;
		}
		for (int j = 0; j < 10; j++) {
			cout << Arr[j] << endl;//用别名进行输出
		}
		//先定义数组的类型，再定义引用
		typedef int(ARRAY_TYPE)[10];
		////类型 & 别名=原名;
		ARRAY_TYPE &Arr1 = arr;
		for (int j = 0; j < 10; j++) {
			cout << Arr1[j] << endl;//用别名进行输出
		}

	}	
========================================================================================参数的传递方式：值传递、地址传递、引用传递
	//值传递
	void chuandi(int a ,int b) {
		int temp = a;
		a = b;
		b = temp;
		cout << "a="<<a <<"b="<< b << endl;
	}
	void test() {
		int a = 10;
		int b = 20;
		chuandi(a, b);
		cout << "a=" << a << "b=" << b << endl;
	}
	//地址传递
	void dizhichuandi(int *a ,int *b) {
		int temp = *a;
		*a = *b;
		*b = temp;
	}
	void test2() {
		int a = 10;
		int b = 20;
		dizhichuandi(&a, &b);
		cout << "a=" << a << "b=" << b << endl;
	}
	//引用传递
	void yinyong(int &a ,int &b) {//传入参数时候，相当于是 int &a=a ,int &b=b
		int temp = a;
		a = b;
		b = temp;
	}
	void test3() {
		int a = 10;
		int b = 20;
		yinyong(a, b);
		cout << "a=" << a << "  b=" << b << endl;  
	}
========================================================================================引用的注意事项：


	//1.不要反悔局部变量的引用
	int & fanhui() {
		int a = 10;
		return a;//执行完这个函数后a已经不存在了
	}
	void test4() {
		int & a = fanhui();
		cout << a << endl;//当输出一行的时候，编译器做了优化，结果是正确的，但是输出多行的时候，会输出乱码
		cout << a << endl;
		cout << a << endl;
	}
	//2.如果函数的返回值是一个引用，则这个函数的返回值可以作为一个左值进行运算
	int& myfun() {
		static int a = 10;
		return a;	
	}
	void test5() {
		int &a = myfun();
		cout << a << endl;//当声明为静态的时候，是不会被释放的
		cout << a << endl;
		myfun() = 100;//相当于a=100;
		cout << a << endl;//100
	}
========================================================================================引用的本质：
	引用就是一个指针常量，所以引用必须要初始化，初始化后不可改变指向
========================================================================================指针：
	struct Person {
	int age;
	};
	void mallocSpace(Person **p) {//**p 指向Person本体  *p指针 p指针的指针
		*p=(Person *)malloc(sizeof(Person));
		(*p)->age = 100;
	}
	void test() {
		Person *p = NULL;
		mallocSpace(&p);
		cout << p->age << endl;
	}
	void mallocSpace2(Person* &p) {//Person * &p=p
		p=(Person *)malloc(sizeof(Person));
		p->age = 200;

	}
	void test1() {
		Person *p = NULL;
		mallocSpace2(p);
		cout << p->age << endl;
	}
========================================================================================int p; //这是一个普通的整型变量
int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针
int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组
int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组
int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针
int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.
int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据
Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针
int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.

========================================================================================常量的引用：
	//常量的引用
	void test() {
		//int & ref = 10;//引用必须引用一个合法的内存空间
		const int & ref = 10;//加入const语法通过，编译器优化 int temp=10;const int &ref=temp;这样是合法的
		//ref = 1000;//不可以直接修改
		int *p = (int *)&ref;
		*p = 1000;
		cout << "ref=" << ref << endl;
	}
	void showvalue( const int &a) {//前边加一个const的目的是在showvalue这个函数中是不可以再修改a的值的
		//a = 99;//加了const后不可以修改
		cout << a << endl;
	}
	//常量引用的场景:形参中加入const防止误操作修改形参的值从而修改整个值
	void test1() {
		int a = 100;
		showvalue(a);
	}
	int main()
	{
		test1();
		system("pause");
		return 0;
	}
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================

============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================
============================================================================================












